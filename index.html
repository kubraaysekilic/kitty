<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cozy Kitty Jump</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Quicksand:wght@400;600;700&display=swap');
        
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        * {
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            font-family: 'Quicksand', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .game-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(255,245,248,0.9) 0%, rgba(255,245,248,0) 100%);
        }

        h1 {
            color: #E8A0BF;
            font-size: 1.8rem;
            margin: 0;
            text-shadow: 2px 2px 0px #fff, 0 0 20px rgba(232, 160, 191, 0.3);
            font-weight: 700;
        }

        .score-board {
            display: flex;
            gap: 30px;
        }

        .score-item {
            color: #9B8AA5;
            font-size: 1.1rem;
            font-weight: 600;
            background: rgba(255,255,255,0.7);
            padding: 8px 16px;
            border-radius: 20px;
            border: 2px solid #E8A0BF;
        }

        .score-item span {
            color: #E8A0BF;
            font-weight: bold;
            font-size: 1.2rem;
        }

        .canvas-wrapper {
            flex: 1;
            width: 100%;
            position: relative;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #9B8AA5;
            font-size: 1rem;
            background: rgba(255,255,255,0.8);
            padding: 10px 20px;
            border-radius: 20px;
            border: 2px solid #E8A0BF;
            z-index: 10;
        }

        .instructions kbd {
            background: linear-gradient(135deg, #FFE5EC 0%, #E6F7FF 100%);
            padding: 4px 10px;
            border-radius: 6px;
            border: 2px solid #E8A0BF;
            color: #9B8AA5;
            font-family: inherit;
            font-weight: 600;
        }

        #startMessage {
            position: absolute;
            color: #9B8AA5;
            font-size: 2rem;
            text-shadow: 2px 2px 0px #fff;
            pointer-events: none;
            font-weight: 600;
            z-index: 20;
        }

        #gameOverMessage {
            display: none;
            position: absolute;
            color: #E8A0BF;
            font-size: 2.5rem;
            text-shadow: 2px 2px 0px #fff;
            pointer-events: none;
            font-weight: 700;
            z-index: 20;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>üê± Cozy Kitty Jump üå∏</h1>
            <div class="score-board">
                <div class="score-item">Score: <span id="score">0</span></div>
                <div class="score-item">Best: <span id="highScore">0</span></div>
            </div>
        </div>
        <div class="canvas-wrapper">
            <canvas id="gameCanvas"></canvas>
            <div id="startMessage">Press SPACE or Click to Start! üåü</div>
            <div id="gameOverMessage">Game Over! üòø Press SPACE to Restart</div>
        </div>
        <p class="instructions">Press <kbd>SPACE</kbd> or <kbd>Click</kbd> to Jump üêæ</p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const highScoreElement = document.getElementById('highScore');
        const startMessage = document.getElementById('startMessage');
        const gameOverMessage = document.getElementById('gameOverMessage');

        // Fullscreen canvas setup
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', () => {
            resizeCanvas();
            if (!gameRunning) initialDraw();
        });

        // Game state
        let gameRunning = false;
        let gameOver = false;
        let score = 0;
        let highScore = localStorage.getItem('jumpRunnerHighScore') || 0;
        highScoreElement.textContent = highScore;

        // Dynamic ground position (80% of screen height)
        function getGroundY() {
            return canvas.height * 0.8;
        }

        // Cat player - bigger and cuter!
        const player = {
            x: 100,
            width: 70,
            height: 70,
            velocityY: 0,
            jumping: false,
            color: '#FFB5C5',
            innerColor: '#FFD4E0',
            eyeColor: '#3D3D3D',
            noseColor: '#FF9EBA',
            blushColor: 'rgba(255, 150, 180, 0.6)',
            get y() { return getGroundY() - this.height; }
        };
        player._y = player.y;

        // Flowers decoration
        let flowers = [];
        function initFlowers() {
            flowers = [];
            for (let i = 0; i < 15; i++) {
                flowers.push({
                    x: Math.random() * canvas.width,
                    yOffset: 10 + Math.random() * 40,
                    size: Math.random() * 10 + 8,
                    color: ['#FFB5C5', '#B4D4E7', '#C9B1FF', '#FFFACD', '#98D4BB'][Math.floor(Math.random() * 5)]
                });
            }
        }
        initFlowers();

        // Gravity and jump - adjusted for fullscreen
        const gravity = 1.2;
        const jumpForce = -22;

        // Obstacles
        let obstacles = [];
        let obstacleTimer = 0;
        let obstacleInterval = 100;
        let gameSpeed = 5;

        // Clouds for decoration - more clouds for fullscreen
        let clouds = [];
        function initClouds() {
            clouds = [];
            for (let i = 0; i < 8; i++) {
                clouds.push({
                    x: Math.random() * canvas.width,
                    y: 60 + Math.random() * 120,
                    width: 80 + Math.random() * 60,
                    height: 40 + Math.random() * 30
                });
            }
        }
        initClouds();

        // Ground decoration
        let groundLines = [];
        function initGroundLines() {
            groundLines = [];
            for (let i = 0; i < Math.ceil(canvas.width / 40); i++) {
                groundLines.push({ x: i * 40, width: Math.random() * 30 + 10 });
            }
        }
        initGroundLines();

        function drawBackground() {
            const groundY = getGroundY();
            
            // Soft pastel sky gradient
            const skyGradient = ctx.createLinearGradient(0, 0, 0, groundY);
            skyGradient.addColorStop(0, '#E6F7FF');
            skyGradient.addColorStop(0.3, '#FFF5F8');
            skyGradient.addColorStop(0.7, '#F5E6FF');
            skyGradient.addColorStop(1, '#FFE8F0');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, groundY);

            // Soft sun with glow - positioned relative to screen
            const sunX = canvas.width - 120;
            const sunY = 100;
            ctx.fillStyle = '#FFFACD';
            ctx.beginPath();
            ctx.arc(sunX, sunY, 60, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFF8E7';
            ctx.beginPath();
            ctx.arc(sunX, sunY, 45, 0, Math.PI * 2);
            ctx.fill();
            // Sun blush
            ctx.fillStyle = 'rgba(255, 182, 193, 0.4)';
            ctx.beginPath();
            ctx.arc(sunX - 15, sunY + 8, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(sunX + 15, sunY + 8, 10, 0, Math.PI * 2);
            ctx.fill();
            // Sun eyes (closed happy eyes)
            ctx.strokeStyle = '#E8A0BF';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(sunX - 12, sunY - 5, 8, 0.8 * Math.PI, 0.2 * Math.PI);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(sunX + 12, sunY - 5, 8, 0.8 * Math.PI, 0.2 * Math.PI);
            ctx.stroke();
            // Sun smile
            ctx.beginPath();
            ctx.arc(sunX, sunY + 5, 15, 0.1 * Math.PI, 0.9 * Math.PI);
            ctx.stroke();

            // Fluffy pastel clouds
            clouds.forEach(cloud => {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.beginPath();
                ctx.ellipse(cloud.x, cloud.y, cloud.width / 2, cloud.height / 2, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cloud.x - cloud.width / 3, cloud.y + 5, cloud.width / 3, cloud.height / 2.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(cloud.x + cloud.width / 3, cloud.y + 5, cloud.width / 3, cloud.height / 2.5, 0, 0, Math.PI * 2);
                ctx.fill();
                // Pink tint on clouds
                ctx.fillStyle = 'rgba(255, 213, 224, 0.4)';
                ctx.beginPath();
                ctx.ellipse(cloud.x, cloud.y + 5, cloud.width / 3, cloud.height / 3, 0, 0, Math.PI * 2);
                ctx.fill();
            });

            // Soft pastel ground
            const groundGradient = ctx.createLinearGradient(0, groundY, 0, canvas.height);
            groundGradient.addColorStop(0, '#C8E6C9');
            groundGradient.addColorStop(0.3, '#B5DEB8');
            groundGradient.addColorStop(1, '#98D4A0');
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

            // Cute grass tufts
            ctx.fillStyle = '#8BC98F';
            groundLines.forEach(line => {
                ctx.beginPath();
                ctx.moveTo(line.x, groundY);
                ctx.quadraticCurveTo(line.x + 4, groundY - 12, line.x + 8, groundY);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(line.x + 12, groundY);
                ctx.quadraticCurveTo(line.x + 16, groundY - 10, line.x + 20, groundY);
                ctx.fill();
            });

            // Draw flowers
            flowers.forEach(flower => {
                const flowerY = groundY + flower.yOffset;
                // Flower petals
                ctx.fillStyle = flower.color;
                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    const angle = (i * 72) * Math.PI / 180;
                    ctx.ellipse(
                        flower.x + Math.cos(angle) * flower.size * 0.4,
                        flowerY + Math.sin(angle) * flower.size * 0.4,
                        flower.size * 0.5,
                        flower.size * 0.5,
                        0, 0, Math.PI * 2
                    );
                    ctx.fill();
                }
                // Flower center
                ctx.fillStyle = '#FFFACD';
                ctx.beginPath();
                ctx.arc(flower.x, flowerY, flower.size * 0.35, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawPlayer() {
            const groundY = getGroundY();
            const px = player.x;
            const py = player._y;
            const pw = player.width;
            const ph = player.height;

            // Soft shadow
            ctx.fillStyle = 'rgba(200, 180, 200, 0.35)';
            ctx.beginPath();
            ctx.ellipse(px + pw / 2, groundY + 8, pw / 2 + 8, 12, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cute curly tail
            ctx.strokeStyle = player.color;
            ctx.lineWidth = 10;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(px + pw - 5, py + ph - 15);
            ctx.bezierCurveTo(px + pw + 25, py + ph - 20, px + pw + 30, py + ph - 50, px + pw + 15, py + ph - 60);
            ctx.stroke();
            // Tail tip
            ctx.fillStyle = '#FFD4E0';
            ctx.beginPath();
            ctx.arc(px + pw + 15, py + ph - 62, 8, 0, Math.PI * 2);
            ctx.fill();

            // Cat ears - bigger and rounder
            ctx.fillStyle = player.color;
            // Left ear
            ctx.beginPath();
            ctx.moveTo(px + 8, py + 10);
            ctx.quadraticCurveTo(px - 5, py - 25, px + 20, py + 5);
            ctx.fill();
            // Right ear
            ctx.beginPath();
            ctx.moveTo(px + pw - 8, py + 10);
            ctx.quadraticCurveTo(px + pw + 5, py - 25, px + pw - 20, py + 5);
            ctx.fill();

            // Inner ears (pink)
            ctx.fillStyle = player.noseColor;
            ctx.beginPath();
            ctx.moveTo(px + 10, py + 8);
            ctx.quadraticCurveTo(px + 2, py - 12, px + 18, py + 6);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(px + pw - 10, py + 8);
            ctx.quadraticCurveTo(px + pw - 2, py - 12, px + pw - 18, py + 6);
            ctx.fill();

            // Cat body (more rounded, cuter shape)
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.roundRect(px, py, pw, ph, 20);
            ctx.fill();

            // Body highlight (belly)
            ctx.fillStyle = player.innerColor;
            ctx.beginPath();
            ctx.ellipse(px + pw/2, py + ph/2 + 5, pw/2 - 12, ph/2 - 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes - BIGGER and cuter kawaii style
            const eyeY = py + 25;
            const leftEyeX = px + 20;
            const rightEyeX = px + 50;
            
            // Eye whites
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(leftEyeX, eyeY, 14, 16, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(rightEyeX, eyeY, 14, 16, 0, 0, Math.PI * 2);
            ctx.fill();

            // Pupils - big and shiny
            ctx.fillStyle = player.eyeColor;
            ctx.beginPath();
            ctx.ellipse(leftEyeX + 2, eyeY + 2, 9, 11, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(rightEyeX + 2, eyeY + 2, 9, 11, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eye sparkles - multiple for extra cute
            ctx.fillStyle = '#fff';
            // Big sparkles
            ctx.beginPath();
            ctx.arc(leftEyeX - 2, eyeY - 4, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(rightEyeX - 2, eyeY - 4, 4, 0, Math.PI * 2);
            ctx.fill();
            // Small sparkles
            ctx.beginPath();
            ctx.arc(leftEyeX + 4, eyeY + 4, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(rightEyeX + 4, eyeY + 4, 2, 0, Math.PI * 2);
            ctx.fill();

            // Rosy blush circles - bigger and more visible
            ctx.fillStyle = player.blushColor;
            ctx.beginPath();
            ctx.ellipse(px + 5, eyeY + 15, 10, 6, -0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(px + pw - 5, eyeY + 15, 10, 6, 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Cute little nose - heart shaped
            ctx.fillStyle = player.noseColor;
            ctx.beginPath();
            ctx.moveTo(px + pw/2, eyeY + 18);
            ctx.bezierCurveTo(px + pw/2 - 6, eyeY + 14, px + pw/2 - 6, eyeY + 22, px + pw/2, eyeY + 26);
            ctx.bezierCurveTo(px + pw/2 + 6, eyeY + 22, px + pw/2 + 6, eyeY + 14, px + pw/2, eyeY + 18);
            ctx.fill();

            // Mouth (cute cat :3 mouth)
            ctx.strokeStyle = '#C9A0B5';
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(px + pw/2 - 12, eyeY + 32);
            ctx.quadraticCurveTo(px + pw/2 - 6, eyeY + 38, px + pw/2, eyeY + 32);
            ctx.quadraticCurveTo(px + pw/2 + 6, eyeY + 38, px + pw/2 + 12, eyeY + 32);
            ctx.stroke();

            // Whiskers - longer and cuter
            ctx.strokeStyle = '#D4B8C9';
            ctx.lineWidth = 2;
            // Left whiskers
            ctx.beginPath();
            ctx.moveTo(px + 8, eyeY + 20);
            ctx.lineTo(px - 18, eyeY + 15);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(px + 8, eyeY + 26);
            ctx.lineTo(px - 18, eyeY + 28);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(px + 8, eyeY + 32);
            ctx.lineTo(px - 15, eyeY + 40);
            ctx.stroke();
            // Right whiskers
            ctx.beginPath();
            ctx.moveTo(px + pw - 8, eyeY + 20);
            ctx.lineTo(px + pw + 18, eyeY + 15);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(px + pw - 8, eyeY + 26);
            ctx.lineTo(px + pw + 18, eyeY + 28);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(px + pw - 8, eyeY + 32);
            ctx.lineTo(px + pw + 15, eyeY + 40);
            ctx.stroke();

            // Little paws at the bottom
            ctx.fillStyle = player.innerColor;
            ctx.beginPath();
            ctx.ellipse(px + 15, py + ph - 5, 10, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(px + pw - 15, py + ph - 5, 10, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            // Paw pads
            ctx.fillStyle = player.noseColor;
            ctx.beginPath();
            ctx.arc(px + 15, py + ph - 3, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(px + pw - 15, py + ph - 3, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawObstacle(obstacle) {
            const groundY = getGroundY();
            
            // Soft shadow
            ctx.fillStyle = 'rgba(200, 180, 200, 0.3)';
            ctx.beginPath();
            ctx.ellipse(obstacle.x + obstacle.width / 2, groundY + 8, obstacle.width / 2 + 5, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Cute mushroom obstacle - bigger
            const capHeight = obstacle.height * 0.55;
            const stemHeight = obstacle.height * 0.55;
            const capWidth = obstacle.width * 1.5;
            
            // Mushroom stem
            ctx.fillStyle = '#FFF8F0';
            ctx.beginPath();
            ctx.roundRect(
                obstacle.x + obstacle.width * 0.1,
                obstacle.y + capHeight - 8,
                obstacle.width * 0.8,
                stemHeight,
                [0, 0, 12, 12]
            );
            ctx.fill();

            // Stem highlight
            ctx.fillStyle = '#FFFDF8';
            ctx.beginPath();
            ctx.roundRect(
                obstacle.x + obstacle.width * 0.25,
                obstacle.y + capHeight,
                obstacle.width * 0.25,
                stemHeight - 15,
                6
            );
            ctx.fill();

            // Mushroom cap
            const capColors = ['#FFB5C5', '#B4D4E7', '#C9B1FF', '#FFFACD', '#B8E6C1'];
            const capColor = capColors[Math.floor(obstacle.x) % 5];
            ctx.fillStyle = capColor;
            ctx.beginPath();
            ctx.ellipse(
                obstacle.x + obstacle.width / 2,
                obstacle.y + capHeight / 2,
                capWidth / 2,
                capHeight / 2,
                0, 0, Math.PI * 2
            );
            ctx.fill();

            // Cute spots on cap
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(obstacle.x + obstacle.width * 0.25, obstacle.y + capHeight * 0.35, 7, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(obstacle.x + obstacle.width * 0.75, obstacle.y + capHeight * 0.4, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(obstacle.x + obstacle.width * 0.5, obstacle.y + capHeight * 0.2, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(obstacle.x + obstacle.width * 0.6, obstacle.y + capHeight * 0.55, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        function spawnObstacle() {
            const groundY = getGroundY();
            const height = Math.random() * 40 + 60;
            const width = Math.random() * 20 + 35;
            obstacles.push({
                x: canvas.width,
                y: groundY - height,
                width: width,
                height: height
            });
        }

        function updatePlayer() {
            const groundY = getGroundY();
            
            // Apply gravity
            player.velocityY += gravity;
            player._y += player.velocityY;

            // Ground collision
            if (player._y >= groundY - player.height) {
                player._y = groundY - player.height;
                player.velocityY = 0;
                player.jumping = false;
            }
        }

        function updateObstacles() {
            // Move obstacles
            obstacles.forEach(obstacle => {
                obstacle.x -= gameSpeed;
            });

            // Remove off-screen obstacles
            obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);

            // Spawn new obstacles
            obstacleTimer++;
            if (obstacleTimer >= obstacleInterval) {
                spawnObstacle();
                obstacleTimer = 0;
                // Randomize next spawn time
                obstacleInterval = Math.random() * 60 + 60;
            }
        }

        function updateClouds() {
            clouds.forEach(cloud => {
                cloud.x -= gameSpeed * 0.3;
                if (cloud.x + cloud.width < 0) {
                    cloud.x = canvas.width + cloud.width;
                    cloud.y = Math.random() * 80 + 30;
                }
            });
        }

        function updateGroundLines() {
            groundLines.forEach(line => {
                line.x -= gameSpeed;
                if (line.x + line.width < 0) {
                    line.x = canvas.width;
                    line.width = Math.random() * 30 + 10;
                }
            });
        }

        function updateFlowers() {
            flowers.forEach(flower => {
                flower.x -= gameSpeed * 0.5;
                if (flower.x + flower.size < 0) {
                    flower.x = canvas.width + flower.size;
                    flower.yOffset = 10 + Math.random() * 40;
                    flower.color = ['#FFB5C5', '#B4D4E7', '#C9B1FF', '#FFFACD', '#98D4BB'][Math.floor(Math.random() * 5)];
                }
            });
        }

        function checkCollision() {
            for (let obstacle of obstacles) {
                // Smaller hitbox for more forgiving gameplay
                const hitboxPadding = 10;
                if (player.x + hitboxPadding < obstacle.x + obstacle.width - 5 &&
                    player.x + player.width - hitboxPadding > obstacle.x + 5 &&
                    player._y + hitboxPadding < obstacle.y + obstacle.height &&
                    player._y + player.height > obstacle.y + 10) {
                    return true;
                }
            }
            return false;
        }

        function jump() {
            if (!player.jumping && gameRunning && !gameOver) {
                player.velocityY = jumpForce;
                player.jumping = true;
            }
        }

        function startGame() {
            if (!gameRunning && !gameOver) {
                gameRunning = true;
                startMessage.style.display = 'none';
                gameLoop();
            } else if (gameOver) {
                resetGame();
            }
        }

        function resetGame() {
            gameOver = false;
            gameRunning = true;
            score = 0;
            gameSpeed = 5;
            obstacles = [];
            obstacleTimer = 0;
            player._y = getGroundY() - player.height;
            player.velocityY = 0;
            player.jumping = false;
            scoreElement.textContent = '0';
            gameOverMessage.style.display = 'none';
            gameLoop();
        }

        function endGame() {
            gameOver = true;
            gameRunning = false;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('jumpRunnerHighScore', highScore);
                highScoreElement.textContent = highScore;
            }
            gameOverMessage.style.display = 'block';
        }

        function gameLoop() {
            if (!gameRunning) return;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background
            drawBackground();

            // Update game elements
            updatePlayer();
            updateObstacles();
            updateClouds();
            updateGroundLines();
            updateFlowers();

            // Draw obstacles
            obstacles.forEach(obstacle => drawObstacle(obstacle));

            // Draw player
            drawPlayer();

            // Check collision
            if (checkCollision()) {
                endGame();
                return;
            }

            // Update score
            score++;
            scoreElement.textContent = Math.floor(score / 10);

            // Increase difficulty over time
            if (score % 500 === 0 && gameSpeed < 12) {
                gameSpeed += 0.5;
            }

            requestAnimationFrame(gameLoop);
        }

        // Initial draw
        function initialDraw() {
            player._y = getGroundY() - player.height;
            drawBackground();
            drawPlayer();
            startMessage.style.display = 'block';
            startMessage.style.top = '50%';
            startMessage.style.left = '50%';
            startMessage.style.transform = 'translate(-50%, -50%)';
            gameOverMessage.style.top = '50%';
            gameOverMessage.style.left = '50%';
            gameOverMessage.style.transform = 'translate(-50%, -50%)';
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                if (!gameRunning && !gameOver) {
                    startGame();
                } else if (gameOver) {
                    resetGame();
                } else {
                    jump();
                }
            }
        });

        canvas.addEventListener('click', () => {
            if (!gameRunning && !gameOver) {
                startGame();
            } else if (gameOver) {
                resetGame();
            } else {
                jump();
            }
        });

        // Touch support for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameRunning && !gameOver) {
                startGame();
            } else if (gameOver) {
                resetGame();
            } else {
                jump();
            }
        });

        // Initialize
        initialDraw();
    </script>
</body>
</html>
